[{"title":"Type","type":0,"sectionRef":"#","url":"/GreenTea/api/Type","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#types","content":" "},{"title":"Range​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#Range","content":"&lt;/&gt; type Range = { min: number?, minExclusive: boolean, max: number?, maxExclusive: boolean }   "},{"title":"Cause​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#Cause","content":"&lt;/&gt; type Cause = { ok: boolean, encompassingType: Type?, errs: {{ type: any, input: any?, message: string? }}, formatErr: (self: Cause) → string } Represents the result of a :matches() call. Includes a __tostring metamethod, which formats to a readable error. "},{"title":"Properties​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#properties","content":" "},{"title":"kind​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#kind","content":"&lt;/&gt; Type.kind: string   "},{"title":"meta​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#meta","content":"&lt;/&gt; Type.meta: {[string]: any}? Contains user-specified metadata about the type.  "},{"title":"basic​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#basic","content":"&lt;/&gt; Type.basic: { typeof: string?, type: string? }?   "},{"title":"any​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#any","content":"&lt;/&gt; Type.any: {allowNil: boolean?}?   "},{"title":"unknown​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#unknown","content":"&lt;/&gt; Type.unknown: {allowNil: boolean?}?   "},{"title":"custom​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#custom","content":"&lt;/&gt; Type.custom: { type: Type?, name: string, typechecker: (any) → ( boolean, any? ) }?   "},{"title":"number​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#number","content":"&lt;/&gt; Type.number: { range: Range?, integer: boolean? }?   "},{"title":"string​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#string","content":"&lt;/&gt; Type.string: { pattern: string?, bytes: Range?, graphemes: Range?, unicode: boolean? }?   "},{"title":"thread​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#thread","content":"&lt;/&gt; Type.thread: {status: {[CoroutineStatus]: boolean}?}?   "},{"title":"instanceIsA​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#instanceIsA","content":"&lt;/&gt; Type.instanceIsA: {class: string}?   "},{"title":"literal​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#literal","content":"&lt;/&gt; Type.literal: {value: any}?   "},{"title":"tuple​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#tuple","content":"&lt;/&gt; Type.tuple: { contents: {Type}, vararg: Type? }?   "},{"title":"vararg​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#vararg","content":"&lt;/&gt; Type.vararg: { type: Type, length: Range? }?   "},{"title":"fn​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#fn","content":"&lt;/&gt; Type.fn: { args: Type, returns: Type }?   "},{"title":"table​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#table","content":"&lt;/&gt; Type.table: { contents: {[string]: Type}, indexer: { key: Type, value: Type }, array: boolean?, count: Range?, raw: boolean? }?   "},{"title":"intersection​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#intersection","content":"&lt;/&gt; Type.intersection: {contents: {Type}}?   "},{"title":"union​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#union","content":"&lt;/&gt; Type.union: { contents: {Type}, optional: boolean? }?  "},{"title":"Functions​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#functions","content":" "},{"title":"matches​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#matches","content":"&lt;/&gt; Type.matches( self: Type, ...: any ) → ( boolean, Cause ) Returns a value with information about whether or not the input matches the type.  "},{"title":"assert​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#assert","content":"&lt;/&gt; Type.assert( self: Type, ...: T... ) → T... Errors if the input does not match the type, otherwise returns the input.  "},{"title":"format​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#format","content":"&lt;/&gt; Type.format(self: Type) → string Formats the type for display to the user.  "},{"title":"wrapFn​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#wrapFn","content":"&lt;/&gt; Type.wrapFn( self: Type, fn: T ) → T Wraps a function with type asserts for its input args and returns.  "},{"title":"type​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#type","content":"&lt;/&gt; Type.type(self: any) → ...any In type definitions via typeof(Type.type()), returns the Luau type this GreenTea type represents. At runtime, returns self. This allows you to compose complex GreenTea types by passing GreenTea.type() into a GreenTea constructor. (Only applies when &quot;built&quot; with GreenTea.build(GreenTea constructors here))  "},{"title":"formatErr​","type":1,"pageTitle":"Type","url":"/GreenTea/api/Type#formatErr","content":"&lt;/&gt; Type.formatErr( self: Type, cause: Cause ) → string Formats the type for display to the user highlighting a specific type. "},{"title":"GreenTea","type":0,"sectionRef":"#","url":"/GreenTea/api/GreenTea","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#types","content":" "},{"title":"RangeInput​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#RangeInput","content":"&lt;/&gt; type RangeInput = string | number | { min: number?, minExclusive: boolean?, max: number?, maxExclusive: boolean? } A value that can be parsed as a range. As a string, can be &quot;[min, max]&quot;, &quot;(min, max)&quot;, &quot;(min, max]&quot;, &quot;(, max]&quot; etc. or a number max inclusive. As a number, it's interpreted as a number max inclusive. "},{"title":"Properties​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#properties","content":" "},{"title":"isA​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#isA","content":"&lt;/&gt; GreenTea.isA: {[string]: any} Types for individual instance classes. Index this to get a type that matches instances of that class. For dynamic class names, or for classes not yet added here, call this with GreenTea.IsA(&quot;ClassName&quot;). "},{"title":"Functions​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#functions","content":" "},{"title":"isGreenTeaType​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#isGreenTeaType","content":"&lt;/&gt; GreenTea.isGreenTeaType(value: any) → () Returns whether or not the input value is a GreenTea.Type object.  "},{"title":"any​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#any","content":"&lt;/&gt; GreenTea.any(options: {allowNil: boolean?}?) → any Creates a new GreenTea Type that matches any value, excluding nil.  "},{"title":"unknown​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#unknown","content":"&lt;/&gt; GreenTea.unknown(options: {allowNil: boolean?}?) → unknown Creates a new GreenTea Type that matches any value, excluding nil. This returns the unknown type, which has different behavior from any. The runtime typechecking behavior is the same as GreenTea.any.  "},{"title":"never​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#never","content":"&lt;/&gt; GreenTea.never() → never Creates a new GreenTea Type that matches no values.  "},{"title":"boolean​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#boolean","content":"&lt;/&gt; GreenTea.boolean() → boolean Creates a new GreenTea Type that matches boolean values.  "},{"title":"Instance​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#Instance","content":"&lt;/&gt; GreenTea.Instance() → Instance  Creates a new GreenTea Type that matches number values.  "},{"title":"coroutine​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#coroutine","content":"&lt;/&gt; GreenTea.coroutine(options: {status: CoroutineStatus | {CoroutineStatus} | nil}?) → thread Creates a new GreenTea Type that matches coroutine values.  "},{"title":"buffer​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#buffer","content":"&lt;/&gt; GreenTea.buffer() → buffer Creates a new GreenTea Type that matches buffer values.  "},{"title":"none​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#none","content":"&lt;/&gt; GreenTea.none() → nil Creates a new GreenTea Type that matches nil values.  "},{"title":"literal​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#literal","content":"&lt;/&gt; GreenTea.literal(value: T) → T Creates a new GreenTea Type that matches a value literally. This is checked with a basic == comparison.  "},{"title":"withCustom​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#withCustom","content":"&lt;/&gt; GreenTea.withCustom( type: T, typechecker: (any) → ( boolean, any? ), name: string? ) → T Creates a new GreenTea Type that matches a custom typechecker with GreenTea type as a base.  "},{"title":"custom​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#custom","content":"&lt;/&gt; GreenTea.custom( typechecker: (any) → ( boolean, any? ), name: string? ) → any Creates a new GreenTea Type that matches a custom typechecker with any as the base type.  "},{"title":"isA​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#isA","content":"&lt;/&gt; GreenTea.isA(class: string) → any Call IsA to get a type that matches instances of that class.  "},{"title":"number​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#number","content":"&lt;/&gt; GreenTea.number(limits: { range: RangeInput?, integer: boolean?, nan: boolean?, }?) → number Creates a new GreenTea Type that matches number values. Optionally, you can specify a range and whether the number must be an integer. Regardless of specified limits, the returned Luau type will be a basic number. Limit checking will only be done at runtime. NOTE: NaN is rejected by default. NaN tends to propogate and &quot;poison&quot; numeric values, and it's rarely actually desired. If you want to allow NaN, set nan = true in the limits table.  "},{"title":"string​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#string","content":"&lt;/&gt; GreenTea.string(limits: { pattern: string?, bytes: RangeInput?, graphemes: RangeInput?, unicode: boolean?, }?) → string Creates a new GreenTea Type that matches string values. Optionally, you can specify a pattern, a length range, and whether the string must be utf8. NOTE: this supports both &quot;byte length&quot; and &quot;grapheme length&quot;. Grapheme length is the number of visible characters. In non-english languages, the number of bytes can be significantly higher than the number of graphemes. When using graphemes limit, you should still set a (much-higher) bytes limit to prevent abuse, since graphemes have no upper limit to their size. For this reason, this constructor will error if you do not specify a bytes limit when using graphemes limit. If you really want infinite byte length, set bytes to [0, inf].  "},{"title":"isTypeof​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#isTypeof","content":"&lt;/&gt; GreenTea.isTypeof( typeName: string, value: T? ) → T Creates a new GreenTea Type that matches any typeof(value) type.  "},{"title":"isType​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#isType","content":"&lt;/&gt; GreenTea.isType( typeName: string, value: T? ) → T Creates a new GreenTea Type that matches any type(value) type.  "},{"title":"types not listed here​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#types not listed here","content":"&lt;/&gt; GreenTea.types not listed here() → () A few methods are not listed in the docs so that they don't clutter with basic types. Here's a list: userdata, Vector2, vector, Vector3, CFrame, Color3, UDim, UDim2, Ray, Rect, Region3, BrickColor, Font, Enum, EnumItem. For the most part, any Luau type you'd naturally write likely also exists under GreenTea. Less common types are excluded (for now) to not clutter the library. For the ones that don't exist, you can usually use isTypeof or isType.  "},{"title":"vararg​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#vararg","content":"&lt;/&gt; GreenTea.vararg( type: T, options: { length: RangeInput?, }? ) → ...T Creates a new GreenTea Type that matches a repeating value.  "},{"title":"tuple​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#tuple","content":"&lt;/&gt; GreenTea.tuple(...: T...) → T... Creates a new GreenTea Type that matches a tuple of values. Specify the final value with GreenTea.vararg to match a repeating final value. This properly accepts a tuple as the final or only argument, so don't fear passing a tuple into this by accident.  "},{"title":"args​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#args","content":"&lt;/&gt; GreenTea.args(...: T...) → (T...) → () Used for GreenTea.fn only. This is used to pass args to GreenTea.fn ergonomically.  "},{"title":"returns​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#returns","content":"&lt;/&gt; GreenTea.returns(...: T...) → () → T... Used for GreenTea.fn only. This is used to pass returns to GreenTea.fn ergonomically.  "},{"title":"fn​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#fn","content":"&lt;/&gt; GreenTea.fn( args: (Args...) → (), returns: () → Returns... ) → (Args...) → Returns... Creates a new GreenTea Type that matches a function. This cannot perform any runtime checks on the function's args or returns. The args and returns exist primarily to have an accurate Luau type. They can be inspected at runtime with type.fn.args and type.fn.returns. If you're building a module that consumes GreenTea types, you can use type.fn.args and type.fn.returns to run runtime typechecking yourself. For example, if you were building a RemoteFunction wrapper, you could use type.fn.returns to check that the client returned correct values.  "},{"title":"anyfn​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#anyfn","content":"&lt;/&gt; GreenTea.anyfn() → (...any) → ...any Creates a new GreenTea Type that matches a function with any args and any returns.  "},{"title":"tuplePacked​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#tuplePacked","content":"&lt;/&gt; GreenTea.tuplePacked(...: T...) → () → T... Creates a new GreenTea Type that &quot;smuggles&quot; a tuple as a single value by packing it into the returns. This is useful for accepting GreenTea tuple types to a spot that only accepts a single value. The actual returned type here is equivalent to GreenTea.fn(GreenTea.args(), GreenTea.returns(...)) so some inspections is required at runtime to pull out the tuple: type.fn.returns is the actual tuple value. With Luau typechecking, you can &quot;unsmuggle&quot; the tuple by doing typeof(smuggledTuple()) to get the tuple type.  "},{"title":"table​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#table","content":"&lt;/&gt; GreenTea.table( contents: T, options: { array: boolean?, count: RangeInput?, raw: boolean?, }? ) → T Creates a new GreenTea Type that matches a table. The contents table should be a dictionary of string keys to types. An indexer can be provided with { [keyGreenTeaType] = valueType }. This currently respects both __iter and __index on both the input contents table and tables being checked against. Tables are non-strict by default. Extra values are allowed. If you'd like to make a table strict, add an indexer that denies extra values, like [gt.any()] = gt.never(). By default, array-like definitions do not check for holes. If you would like to check for holes and ensure the array is contiguous, set array to true. If you'd like to enforce an item limit, specify it count the options table. This limits the number of items found by the indexer. Items in the &quot;struct portion&quot; of the table definition do not count. This is not a #table check: the actual items are counted one-by-one as we check them. This lets you also limit the number of items in cases like dynamic dictionaries. raw allows for checking any key types as literally matching to values, including numbers and other non-strings. This will not appear correct as a Luau type; it is primarily intended for compatibility with other runtime typechecking libraries.  "},{"title":"array​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#array","content":"&lt;/&gt; GreenTea.array( value: T, options: { count: RangeInput?, }? ) → {T} Creates a new GreenTea Type that matches an array of values. Convenience function that calls GreenTea.table internally.  "},{"title":"dictionary​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#dictionary","content":"&lt;/&gt; GreenTea.dictionary( key: K, value: V, options: { count: RangeInput?, }? ) → {[K]: V} Creates a new GreenTea Type that matches a dictionary of values. Convenience function that calls GreenTea.table internally.  "},{"title":"union​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#union","content":"&lt;/&gt; GreenTea.union(...: T...) → T... Creates a new GreenTea Type that matches a union of types. This is analogous to the Luau type1 | type2 | ... syntax. This has convenient type definitions for up to 5 input types. When specifying more then 5 input types, you will have to typecast the first item to a Luau type union in order to get correct types.  "},{"title":"intersection​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#intersection","content":"&lt;/&gt; GreenTea.intersection(...: T...) → T... Creates a new GreenTea Type that matches an intersection of types. This is analogous to the Luau type1 &amp; type2 &amp; ... syntax. This has convenient type definitions for up to 5 input types. When specifying more then 5 input types, you will have to typecast the first item to a Luau type intersection in order to get correct types.  "},{"title":"optional​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#optional","content":"&lt;/&gt; GreenTea.optional(value: T) → T? Creates a new GreenTea Type that makes a value optionally, like type? or type | nil in Luau types.  "},{"title":"typeof​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#typeof","content":"&lt;/&gt; GreenTea.typeof( value: T, recursionCheck: {[any]: any}? ) → T Creates a new GreenTea Type matching the inferred type of value. A runtime, this passes tables to GreenTea.table, functions to GreenTea.fn, and so on. This results in a runtime-inferred type roughly equivalent to the Luau typechecker's inferred types.  "},{"title":"typecast​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#typecast","content":"&lt;/&gt; GreenTea.typecast(value: any) → Type Typecasts a value to a GreenTea type. At runtime this will error if the passed-in type is not a GreenTea type. This exists as a convenience function because type :: GreenTea.Type is usually not possible without an any cast like (type :: any) :: GreenTea.Type. This errors at runtime if the passed-in type is not a GreenTea type.  "},{"title":"build​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#build","content":"&lt;/&gt; GreenTea.build(...: T...) → BuiltType&lt;T...&gt; Typecasts a value to be a GreenTea type, with the type stored under the type key so you can get the type with typeof(result.type())  "},{"title":"meta​","type":1,"pageTitle":"GreenTea","url":"/GreenTea/api/GreenTea#meta","content":"&lt;/&gt; GreenTea.meta( gtType: T, meta: {[string]: any} ) → T Adds user-specified metadata to a type. Each key/value pair is added to the type's meta table. This is a shallow merge: any matching key/value pair will be overwritten, and all other key/value pairs will be kept as-is. "}]