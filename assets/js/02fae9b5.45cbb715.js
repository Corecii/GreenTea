"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[331],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},y=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,p=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=s(n),y=r,d=c["".concat(p,".").concat(y)]||c[y]||m[y]||l;return n?a.createElement(d,i(i({ref:t},u),{},{components:n})):a.createElement(d,i({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=y;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o[c]="string"==typeof e?e:r,i[1]=o;for(var s=2;s<l;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}y.displayName="MDXCreateElement"},76647:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>i,default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const l={},i="\ud83c\udf75 GreenTea",o={type:"mdx",permalink:"/GreenTea/",source:"@site/pages/index.md",title:"\ud83c\udf75 GreenTea",description:"An experimental runtime typechecker for Roblox Luau, with matching 'tooling-time' Luau types.",frontMatter:{}},p=[{value:"Features",id:"features",level:2},{value:"Experimental",id:"experimental",level:2},{value:"Install",id:"install",level:2},{value:"with Wally (for Rojo)",id:"with-wally-for-rojo",level:3},{value:"Standalone (for non-Rojo)",id:"standalone-for-non-rojo",level:3},{value:"How Does It Work?",id:"how-does-it-work",level:2},{value:"Examples",id:"examples",level:2},{value:"Easy Mode",id:"easy-mode",level:3},{value:"How it Works",id:"how-it-works",level:3},{value:"Taking in GreenTea types",id:"taking-in-greentea-types",level:3},{value:"<code>t</code> Compatibility",id:"t-compatibility",level:2},{value:"Inspiration",id:"inspiration",level:2},{value:"Future Plans",id:"future-plans",level:2}],s={toc:p},u="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"-greentea"},"\ud83c\udf75 GreenTea"),(0,r.kt)("p",null,"An experimental runtime typechecker for Roblox Luau, with matching 'tooling-time' Luau types."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://corecii.github.io/greentea/"},"Docs")),(0,r.kt)("h2",{id:"features"},"Features"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Check types at runtime (like ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/osyrisrblx/t"},"the t package"),")"),(0,r.kt)("li",{parentName:"ul"},"Build Luau types and runtime types simultaneously (so you have less duplicate code!)"),(0,r.kt)("li",{parentName:"ul"},"Pretty errors that tell you exactly where you went wrong, even for unions and intersections"),(0,r.kt)("li",{parentName:"ul"},"Inspect types at runtime, so you can procedurally check types in weird scenarios, such as when checking a set of Instance attributes."),(0,r.kt)("li",{parentName:"ul"},"Infer types from values"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"t")," compatibility (via ",(0,r.kt)("inlineCode",{parentName:"li"},"GreenTea.t")," \u2014 all ",(0,r.kt)("inlineCode",{parentName:"li"},"t")," tests pass!)")),(0,r.kt)("h2",{id:"experimental"},"Experimental"),(0,r.kt)("p",null,"While this package has had a lot of work put into it, it's largely an experiment. It's a first iteration, so the API can use some improvement \u2014 especially the structure of the generated Type objects, which could have a better shape."),(0,r.kt)("p",null,"Please leave feedback on the issues page. Thank you!"),(0,r.kt)("h2",{id:"install"},"Install"),(0,r.kt)("h3",{id:"with-wally-for-rojo"},"with Wally (for Rojo)"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"https://wally.run/install"},"Install Wally")),(0,r.kt)("li",{parentName:"ol"},"Add GreenTea to your ",(0,r.kt)("inlineCode",{parentName:"li"},"wally.toml"))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Run ",(0,r.kt)("inlineCode",{parentName:"li"},"wally add corecii/GreenTea")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"or")," Add ",(0,r.kt)("inlineCode",{parentName:"li"},'GreenTea = "corecii/GreenTea@0.1.0"')," to your ",(0,r.kt)("inlineCode",{parentName:"li"},"wally.toml"))),(0,r.kt)("h3",{id:"standalone-for-non-rojo"},"Standalone (for non-Rojo)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Download from ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/corecii/greentea/releases"},"the Releases page"))),(0,r.kt)("h2",{id:"how-does-it-work"},"How Does It Work?"),(0,r.kt)("p",null,"GreenTea's runtime code looks like a typical runtime typechecker:\nyou call functions to create typecheckers and compose them together."),(0,r.kt)("p",null,"It has two tricks:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Its function type definitions ",(0,r.kt)("em",{parentName:"li"},"lie")," and say that it's returning ",(0,r.kt)("em",{parentName:"li"},"the type that you're checking for")," instead of a GreenTea.Type object.\nSo while you're composing a runtime type, you're ",(0,r.kt)("em",{parentName:"li"},"also")," composing a Luau type definition!"),(0,r.kt)("li",{parentName:"ol"},"The typechecker it produces is actually an ",(0,r.kt)("em",{parentName:"li"},"object"),", which gives you a runtime-inspectable\ntype definition you can do more advanced stuff with. This also means prettier errors that look a lot like Luau type errors.")),(0,r.kt)("h2",{id:"examples"},"Examples"),(0,r.kt)("h3",{id:"easy-mode"},"Easy Mode"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local gt = require(path.to.GreenTea)\n\nlocal stringType = gt.build(gt.string())\n\n-- equivalent to takesString(value: string)\nlocal function takesString(value: typeof(stringType.type()))\n    -- will error if value is not a string\n    stringType:assert(value)\n\n    -- ...\nend\n")),(0,r.kt)("p",null,"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"gt")," is recommended, because ",(0,r.kt)("inlineCode",{parentName:"p"},"GreenTea")," is a lot to type and ",(0,r.kt)("inlineCode",{parentName:"p"},"gt")," is not!"),(0,r.kt)("h3",{id:"how-it-works"},"How it Works"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local stringTypeRaw = gt.string()\n\n-- stringTypeRaw is typed in Luau as `string`\n-- but at runtime, it\'s really a GreenTea.Type object.\n-- This makes it easy to split it up into a runtime\n-- typechecker and a Luau type:\n\n-- give a name to the type\ntype stringTypeLuau = typeof(stringTypeRaw.type())\n\n-- cast the object to the runtime typechecker type it really is\nlocal stringTypeChecker = gt.typecast(stringTypeRaw)\n\n-- You can think of this like "tricking" Luau into\n-- "giving" us a `string` type.\n-- This is all `GreenTea.build` does -- it typecasts\n-- the value into a GreenTea.Type object, but includes\n-- the original type os you can use `typeof`.\n\n-- But the magic is this also works for more complex types!\n\nlocal catTypeRaw = gt.table({\n    age = gt.number(),\n    meowSound = gt.string(),\n    breed = {\n        [gt.indexer(gt.string())] = gt.number(),\n    },\n})\n\ntype catTypeLuau = typeof(catTypeRaw)\n-- which is the same as...\ntype catTypeSame = {\n    age: number,\n    meowSound: string,\n    breed: { [string]: number },\n}\n\n-- and we can get a runtime typechecker...\nlocal catTypeChecker = gt.typecast(catTypeRaw)\n\n-- OR we can make it really easy on ourselves if we just use `build` from the beginning:\n\nlocal catType = gt.build(gt.table({\n    age = gt.number(),\n    meowSound = gt.string(),\n    breed = {\n        [gt.indexer(gt.string())] = gt.number(),\n    },\n}))\n\n-- catType == catTypeChecker\n-- catTypeLuau == typeof(catTypeChecker.type())\n')),(0,r.kt)("p",null,"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"build")," is recommended because it makes this mostly type-safe:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The returned value is properly typed a GreenTea Type object, so you\nhave typechecked access to GreenTea.Type's properties and methods."),(0,r.kt)("li",{parentName:"ul"},"TypeObject.type() can still be passed to GreenTea constructors to\npass the GreenTea type in."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"build")," runs ",(0,r.kt)("inlineCode",{parentName:"li"},"GreenTea.typeof")," internally, so you can pass it simple tables\nand they'll be converted to the proper ",(0,r.kt)("inlineCode",{parentName:"li"},"GreenTea.table")," type.")),(0,r.kt)("p",null,'In this way, "built" types are for direct use, and "unbuilt" types are for composition\nwith other GreenTea constructors.'),(0,r.kt)("h3",{id:"taking-in-greentea-types"},"Taking in GreenTea types"),(0,r.kt)("p",null,"GreenTea is great for libraries that want to do typechecking, like RemoteEvent wrappers, because you can make the API very ergonomic:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"-- RemoteWrapper.luau\n\nfunction RemoteWrapper.new<T>(greenTeaType: T): RemoteWrapper<T>\n    local self = {\n        typechecker = GreenTea.build(greenTeaType),\n        ...\n    }\n\n    return setmetatable(self, RemoteWrapper)\nend\n\nfunction RemoteWrapper.onServerEvent<T>(self: RemoteWrapper<T>, fn: (player: Player, params: T) -> ())\n    self.event:OnServerEvent(function(player: Player, paramsMaybe: any?)\n        local params = self.typechecker:assert(params)\n        fn(player, params)\n    end)\nend\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"-- CatSpawner.luau\n\nlocal SpawnCat = RemoteWrapper.new({\n    cat = gt.table({\n        age = gt.number(),\n        meowSound = gt.string(),\n        ...\n    }),\n    location = gt.CFrame(),\n    ...\n})\n\nSpawnVehicle:onServerEvent(function(player, params)\n    -- params is properly typed as { cat: { age: number, ...}, location: CFrame, ... }\nend)\n")),(0,r.kt)("h2",{id:"t-compatibility"},(0,r.kt)("inlineCode",{parentName:"h2"},"t")," Compatibility"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"GreenTea.t")," includes all of the methods from the ",(0,r.kt)("inlineCode",{parentName:"p"},"t")," package. See ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/osyrisrblx/t/blob/master/README.md"},"the t package's readme")," for more details."),(0,r.kt)("h2",{id:"inspiration"},"Inspiration"),(0,r.kt)("p",null,"This library was largely inspired by ",(0,r.kt)("inlineCode",{parentName:"p"},"t"),", but also my experience working with t types, working with Luau types, and working with systems that need inspectable type definitions. This is my first attempt at solving all of these problems. I'd really like to see the inversion of this library -- where inspectable runtime type definitions are built from Luau types. But that's more work, so I'll leave it as a TODO!"),(0,r.kt)("h2",{id:"future-plans"},"Future Plans"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Split up ",(0,r.kt)("inlineCode",{parentName:"li"},"GreenTea.luau")," into multiple files. It's too long. But I'm tired and want to move on and actually use this library for cool things."),(0,r.kt)("li",{parentName:"ul"},"Stop lying to the typechecker once it's able to handle all of GreenTea's features."),(0,r.kt)("li",{parentName:"ul"},"Inverted GreenTea, where runtime typecheckers are built from Luau types.")))}c.isMDXComponent=!0}}]);